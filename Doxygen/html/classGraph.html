<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Graph&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b7b7465fbfd562e2a469f90a437ab75"><td class="memItemLeft" align="right" valign="top"><a id="a8b7b7465fbfd562e2a469f90a437ab75"></a>
<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>findVertex</b> (const T &amp;in) const</td></tr>
<tr class="separator:a8b7b7465fbfd562e2a469f90a437ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00be284ea2be3b3d0f0d2e493b70245b"><td class="memItemLeft" align="right" valign="top"><a id="a00be284ea2be3b3d0f0d2e493b70245b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addVertex</b> (const T &amp;in)</td></tr>
<tr class="separator:a00be284ea2be3b3d0f0d2e493b70245b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c903104ad69a7782979fa9caedf163"><td class="memItemLeft" align="right" valign="top"><a id="af9c903104ad69a7782979fa9caedf163"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeVertex</b> (const T &amp;in)</td></tr>
<tr class="separator:af9c903104ad69a7782979fa9caedf163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61af3aafe6277215f5a3b3cc7d58ce2"><td class="memItemLeft" align="right" valign="top"><a id="ac61af3aafe6277215f5a3b3cc7d58ce2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (const T &amp;sourc, const T &amp;dest, double w)</td></tr>
<tr class="separator:ac61af3aafe6277215f5a3b3cc7d58ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8949d071d45bf93e171e275462e1007a"><td class="memItemLeft" align="right" valign="top"><a id="a8949d071d45bf93e171e275462e1007a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>removeEdge</b> (const T &amp;source, const T &amp;dest)</td></tr>
<tr class="separator:a8949d071d45bf93e171e275462e1007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83937ed61b30513471e44512f398851c"><td class="memItemLeft" align="right" valign="top"><a id="a83937ed61b30513471e44512f398851c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addBidirectionalEdge</b> (<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v1, <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v2, double w)</td></tr>
<tr class="separator:a83937ed61b30513471e44512f398851c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb94a42983b1612ddbeade1a2a0132ea"><td class="memItemLeft" align="right" valign="top"><a id="aeb94a42983b1612ddbeade1a2a0132ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>addBidirectionalEdge</b> (const T &amp;sourc, const T &amp;dest, double w)</td></tr>
<tr class="separator:aeb94a42983b1612ddbeade1a2a0132ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd6a84d857dc146c0029f93eba9056d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#accd6a84d857dc146c0029f93eba9056d">updateMst</a> (<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v1, <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v2)</td></tr>
<tr class="memdesc:accd6a84d857dc146c0029f93eba9056d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the Minimum Spanning Tree (MST) edges between two vertices.  <a href="classGraph.html#accd6a84d857dc146c0029f93eba9056d">More...</a><br /></td></tr>
<tr class="separator:accd6a84d857dc146c0029f93eba9056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="memItemLeft" align="right" valign="top"><a id="a0853eac15cdf0f06d63f4b8a7820ec71"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNumVertex</b> () const</td></tr>
<tr class="separator:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41624b03fcb6bd29e4df574a1ec58541"><td class="memItemLeft" align="right" valign="top"><a id="a41624b03fcb6bd29e4df574a1ec58541"></a>
std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVertexSet</b> () const</td></tr>
<tr class="separator:a41624b03fcb6bd29e4df574a1ec58541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1243f481d9929b890dbafe18cc3d8259"><td class="memItemLeft" align="right" valign="top"><a id="a1243f481d9929b890dbafe18cc3d8259"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dfs</b> () const</td></tr>
<tr class="separator:a1243f481d9929b890dbafe18cc3d8259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6e8c33823d6d45d2ab201d64b39483"><td class="memItemLeft" align="right" valign="top"><a id="a4e6e8c33823d6d45d2ab201d64b39483"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dfs</b> (const T &amp;source) const</td></tr>
<tr class="separator:a4e6e8c33823d6d45d2ab201d64b39483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468b6d9b6b1899d4c885324ed14e4f8a"><td class="memItemLeft" align="right" valign="top"><a id="a468b6d9b6b1899d4c885324ed14e4f8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dfsVisit</b> (<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v, std::vector&lt; T &gt; &amp;res) const</td></tr>
<tr class="separator:a468b6d9b6b1899d4c885324ed14e4f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b211a9a1e49216603e6a676df8138ec"><td class="memItemLeft" align="right" valign="top"><a id="a4b211a9a1e49216603e6a676df8138ec"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bfs</b> (const T &amp;source) const</td></tr>
<tr class="separator:a4b211a9a1e49216603e6a676df8138ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea1512afe5ab878301bc806c2eba9d2"><td class="memItemLeft" align="right" valign="top"><a id="a1ea1512afe5ab878301bc806c2eba9d2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDAG</b> () const</td></tr>
<tr class="separator:a1ea1512afe5ab878301bc806c2eba9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06743c0b3e219cfeefa5aade38556cb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a06743c0b3e219cfeefa5aade38556cb7">dfsIsDAG</a> (<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v) const</td></tr>
<tr class="separator:a06743c0b3e219cfeefa5aade38556cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7720cd8fcba892d4550494e91b8d4"><td class="memItemLeft" align="right" valign="top"><a id="ab8c7720cd8fcba892d4550494e91b8d4"></a>
std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>topsort</b> () const</td></tr>
<tr class="separator:ab8c7720cd8fcba892d4550494e91b8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2a0d61524a229a772a299fa6c7706d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4f2a0d61524a229a772a299fa6c7706d">tsp_backtracking</a> (std::vector&lt; int &gt; &amp;path, std::vector&lt; int &gt; &amp;soltuion, double &amp;solution_cost, double current_cost)</td></tr>
<tr class="memdesc:a4f2a0d61524a229a772a299fa6c7706d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem (TSP) using backtracking.  <a href="classGraph.html#a4f2a0d61524a229a772a299fa6c7706d">More...</a><br /></td></tr>
<tr class="separator:a4f2a0d61524a229a772a299fa6c7706d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0a6b6a4bc5023de4f70f4766adef44"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3a0a6b6a4bc5023de4f70f4766adef44">triangularApproximation</a> (std::queue&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;path)</td></tr>
<tr class="memdesc:a3a0a6b6a4bc5023de4f70f4766adef44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an approximation of the Traveling Salesman Problem (TSP) using the Triangular Approximation Method.  <a href="classGraph.html#a3a0a6b6a4bc5023de4f70f4766adef44">More...</a><br /></td></tr>
<tr class="separator:a3a0a6b6a4bc5023de4f70f4766adef44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c17d405f9605b67f0bf26f5256fc0e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4c17d405f9605b67f0bf26f5256fc0e2">nearestNeighborTSP</a> (std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;path, double &amp;distancia)</td></tr>
<tr class="memdesc:a4c17d405f9605b67f0bf26f5256fc0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Traveling Salesman Problem (TSP) solution using the Nearest Neighbor heuristic.  <a href="classGraph.html#a4c17d405f9605b67f0bf26f5256fc0e2">More...</a><br /></td></tr>
<tr class="separator:a4c17d405f9605b67f0bf26f5256fc0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd376ff12b27523b5bfc95ee519bc4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#adbd376ff12b27523b5bfc95ee519bc4f">prim</a> ()</td></tr>
<tr class="memdesc:adbd376ff12b27523b5bfc95ee519bc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes Prim's algorithm to compute the Minimum Spanning Tree (MST) of the graph.  <a href="classGraph.html#adbd376ff12b27523b5bfc95ee519bc4f">More...</a><br /></td></tr>
<tr class="separator:adbd376ff12b27523b5bfc95ee519bc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc51f1e7c6eba74beb6d142b47386d31"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#afc51f1e7c6eba74beb6d142b47386d31">christofidesTSP</a> (<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v)</td></tr>
<tr class="memdesc:afc51f1e7c6eba74beb6d142b47386d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an approximate solution to the Traveling Salesman Problem (TSP) using the Christofides algorithm.  <a href="classGraph.html#afc51f1e7c6eba74beb6d142b47386d31">More...</a><br /></td></tr>
<tr class="separator:afc51f1e7c6eba74beb6d142b47386d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40d2ed94ccfe83e5d406af45f4e837e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#ab40d2ed94ccfe83e5d406af45f4e837e">getOdds</a> ()</td></tr>
<tr class="memdesc:ab40d2ed94ccfe83e5d406af45f4e837e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all vertices in the graph with odd degree.  <a href="classGraph.html#ab40d2ed94ccfe83e5d406af45f4e837e">More...</a><br /></td></tr>
<tr class="separator:ab40d2ed94ccfe83e5d406af45f4e837e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349af962a25bf0117bf56960d5e1c1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a349af962a25bf0117bf56960d5e1c1ab">preorderTraversal</a> (<a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v, std::queue&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;path)</td></tr>
<tr class="memdesc:a349af962a25bf0117bf56960d5e1c1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a preorder traversal starting from a given vertex in the Minimum Spanning Tree (MST).  <a href="classGraph.html#a349af962a25bf0117bf56960d5e1c1ab">More...</a><br /></td></tr>
<tr class="separator:a349af962a25bf0117bf56960d5e1c1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2407e2fa0f7476e408e146933b285faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a2407e2fa0f7476e408e146933b285faf">eulerianPath</a> (std::queue&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;path, <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *v)</td></tr>
<tr class="memdesc:a2407e2fa0f7476e408e146933b285faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an Eulerian path starting from a given vertex and stores it in a queue.  <a href="classGraph.html#a2407e2fa0f7476e408e146933b285faf">More...</a><br /></td></tr>
<tr class="separator:a2407e2fa0f7476e408e146933b285faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec43803a620dc2339ebc28272a41fe0d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aec43803a620dc2339ebc28272a41fe0d">hamiltonian_cycle</a> (std::queue&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; path)</td></tr>
<tr class="memdesc:aec43803a620dc2339ebc28272a41fe0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a Hamiltonian cycle from a given path of vertices.  <a href="classGraph.html#aec43803a620dc2339ebc28272a41fe0d">More...</a><br /></td></tr>
<tr class="separator:aec43803a620dc2339ebc28272a41fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4b460f3a6f3614135db965aa0194da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#aea4b460f3a6f3614135db965aa0194da">mwm</a> ()</td></tr>
<tr class="memdesc:aea4b460f3a6f3614135db965aa0194da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Minimum Weight Matching (MWM) for the odd degree vertices in the graph.  <a href="classGraph.html#aea4b460f3a6f3614135db965aa0194da">More...</a><br /></td></tr>
<tr class="separator:aea4b460f3a6f3614135db965aa0194da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a26b3a6b9c61f02f5b2cd38ad4c6a4953"><td class="memItemLeft" align="right" valign="top"><a id="a26b3a6b9c61f02f5b2cd38ad4c6a4953"></a>
std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertexSet</b></td></tr>
<tr class="separator:a26b3a6b9c61f02f5b2cd38ad4c6a4953"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a676cdfb976eccfa82b631d2094c1cdac"><td class="memItemLeft" align="right" valign="top"><a id="a676cdfb976eccfa82b631d2094c1cdac"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>findVertexIdx</b> (const T &amp;in) const</td></tr>
<tr class="separator:a676cdfb976eccfa82b631d2094c1cdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4517f4351bc7f0348369b25b7c0b44fe"><td class="memItemLeft" align="right" valign="top"><a id="a4517f4351bc7f0348369b25b7c0b44fe"></a>
double **&#160;</td><td class="memItemRight" valign="bottom"><b>distMatrix</b> = nullptr</td></tr>
<tr class="separator:a4517f4351bc7f0348369b25b7c0b44fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9524726f8f3cda3115a0d03e3f6e09"><td class="memItemLeft" align="right" valign="top"><a id="afb9524726f8f3cda3115a0d03e3f6e09"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>pathMatrix</b> = nullptr</td></tr>
<tr class="separator:afb9524726f8f3cda3115a0d03e3f6e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afc51f1e7c6eba74beb6d142b47386d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc51f1e7c6eba74beb6d142b47386d31">&#9670;&nbsp;</a></span>christofidesTSP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::christofidesTSP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an approximate solution to the Traveling Salesman Problem (TSP) using the Christofides algorithm. </p>
<p>This function computes an approximate solution to the TSP for a given starting vertex using the Christofides algorithm:</p><ul>
<li>Constructs a Minimum Spanning Tree (MST) using Prim's algorithm.</li>
<li>Computes a Minimum Weight Matching (MWM) for vertices with odd degree.</li>
<li>Constructs an Eulerian path by combining the MST and MWM.</li>
<li>Converts the Eulerian path into a Hamiltonian cycle and calculates the total distance.</li>
<li>Outputs the sequence of vertices visited in the tour to standard output.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The starting vertex for the TSP tour. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The total distance of the approximate TSP tour. O(V²), where V is the number of vertexes . </dd></dl>

</div>
</div>
<a id="a06743c0b3e219cfeefa5aade38556cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06743c0b3e219cfeefa5aade38556cb7">&#9670;&nbsp;</a></span>dfsIsDAG()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dfsIsDAG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auxiliary function that visits a vertex (v) and its adjacent, recursively. Returns false (not acyclic) if an edge to a vertex in the stack is found. </p>

</div>
</div>
<a id="a2407e2fa0f7476e408e146933b285faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2407e2fa0f7476e408e146933b285faf">&#9670;&nbsp;</a></span>eulerianPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::eulerianPath </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an Eulerian path starting from a given vertex and stores it in a queue. </p>
<p>This function uses a depth-first search approach to construct an Eulerian path starting from the given vertex. It recursively visits each unvisited edge, marks it as visited, and continues to the destination vertex, adding vertices to the queue as the recursion unwinds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A queue to store the vertices in the order they are visited in the Eulerian path. </td></tr>
    <tr><td class="paramname">v</td><td>The starting vertex for the Eulerian path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E), where E is the number of Edges in the graph . </dd></dl>

</div>
</div>
<a id="ab40d2ed94ccfe83e5d406af45f4e837e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40d2ed94ccfe83e5d406af45f4e837e">&#9670;&nbsp;</a></span>getOdds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getOdds</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all vertices in the graph with odd degree. </p>
<p>This function calculates the degree of each vertex in the graph and returns a vector containing all vertices with an odd degree.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Vertex&lt;T&gt;*&gt; A vector containing all vertices with odd degree. </dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E + V), where V is the number of vertexes and E the number of edges in the MSTgraph. </dd></dl>

</div>
</div>
<a id="aec43803a620dc2339ebc28272a41fe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec43803a620dc2339ebc28272a41fe0d">&#9670;&nbsp;</a></span>hamiltonian_cycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::hamiltonian_cycle </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a Hamiltonian cycle from a given path of vertices. </p>
<p>This function constructs a Hamiltonian cycle from a given path of vertices and returns it as a vector of vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A queue containing the vertices in the order of the Hamiltonian path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Vertex&lt;T&gt;*&gt; A vector representing the vertices in the Hamiltonian cycle. </dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V), where V is the number of vertexes in the graph </dd></dl>

</div>
</div>
<a id="aea4b460f3a6f3614135db965aa0194da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4b460f3a6f3614135db965aa0194da">&#9670;&nbsp;</a></span>mwm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::mwm</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Minimum Weight Matching (MWM) for the odd degree vertices in the graph. </p>
<p>This function finds all vertices with an odd degree, and pairs them to create a Minimum Weight Matching (MWM) using a heuristic approach. It updates the MST (Minimum Spanning Tree) with these new edges. O(V²), where V is the number of vertexes. </p>

</div>
</div>
<a id="a4c17d405f9605b67f0bf26f5256fc0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c17d405f9605b67f0bf26f5256fc0e2">&#9670;&nbsp;</a></span>nearestNeighborTSP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::nearestNeighborTSP </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>distancia</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the Traveling Salesman Problem (TSP) solution using the Nearest Neighbor heuristic. </p>
<p>This function computes an approximate solution to the TSP using the Nearest Neighbor heuristic:</p><ol type="1">
<li>Starts from the first vextex.</li>
<li>Iteratively selects the nearest unvisited vertex until all vertices are visited.</li>
<li>Returns to the starting vertex to complete the tour.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Vector to store the vertices in the order of the TSP path. </td></tr>
    <tr><td class="paramname">distancia</td><td>Reference to a variable to store the total distance of the TSP path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V²), where V is the number of vertexes . </dd></dl>

</div>
</div>
<a id="a349af962a25bf0117bf56960d5e1c1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349af962a25bf0117bf56960d5e1c1ab">&#9670;&nbsp;</a></span>preorderTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::preorderTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::queue&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a preorder traversal starting from a given vertex in the Minimum Spanning Tree (MST). </p>
<p>This function performs a recursive preorder traversal starting from the given vertex in the MST of the graph. It visits each vertex in the tree exactly once and adds them to the provided queue in the order they are visited.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The starting vertex for the preorder traversal. </td></tr>
    <tr><td class="paramname">path</td><td>The queue to store the vertices in the order of traversal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E + V), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="adbd376ff12b27523b5bfc95ee519bc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd376ff12b27523b5bfc95ee519bc4f">&#9670;&nbsp;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::prim</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes Prim's algorithm to compute the Minimum Spanning Tree (MST) of the graph. </p>
<p>This function computes the MST using Prim's algorithm. It starts from the first vertice, updates the MST edges iteratively, and maintains a priority queue to efficiently find the next vertex to add to the MST. </p><dl class="section user"><dt>Time complexity</dt><dd>O(E * log(V)), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a3a0a6b6a4bc5023de4f70f4766adef44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0a6b6a4bc5023de4f70f4766adef44">&#9670;&nbsp;</a></span>triangularApproximation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::triangularApproximation </td>
          <td>(</td>
          <td class="paramtype">std::queue&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an approximation of the Traveling Salesman Problem (TSP) using the Triangular Approximation Method. </p>
<p>This function computes an approximation of the TSP using the Triangular Approximation Method:</p><ol type="1">
<li>Constructs a Minimum Spanning Tree (MST) using Prim's algorithm.</li>
<li>Performs a preorder traversal starting from the root of the MST.</li>
<li>Computes the total distance of the path formed by the preorder traversal in the TSP.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A queue to store the vertices in the order of traversal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total distance of the TSP approximation using the Triangular Approximation Method. </dd></dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(E * log(V)), where V is the number of vertexes and E the number of edges in the graph. </dd></dl>

</div>
</div>
<a id="a4f2a0d61524a229a772a299fa6c7706d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2a0d61524a229a772a299fa6c7706d">&#9670;&nbsp;</a></span>tsp_backtracking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::tsp_backtracking </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>solution_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>current_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem (TSP) using backtracking. </p>
<p>This function recursively computes the TSP solution using backtracking. It finds the shortest path that visits every vertex exactly once and returns to the starting vertex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The current path being constructed in the recursion. </td></tr>
    <tr><td class="paramname">solution</td><td>The best solution found by the algorithm. </td></tr>
    <tr><td class="paramname">solution_cost</td><td>The cost of the best solution found. </td></tr>
    <tr><td class="paramname">current_cost</td><td>The current cost of the path being constructed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Time complexity</dt><dd>O(V!), where V is the number of vertexes in the graph. </dd></dl>

</div>
</div>
<a id="accd6a84d857dc146c0029f93eba9056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd6a84d857dc146c0029f93eba9056d">&#9670;&nbsp;</a></span>updateMst()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::updateMst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the Minimum Spanning Tree (MST) edges between two vertices. </p>
<p>This function updates the MST edges between two vertices by adding new edges and setting reverse edges for bidirectional connectivity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>The orig vertex. </td></tr>
    <tr><td class="paramname">v2</td><td>The dest vertex. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Data_Structures/<a class="el" href="Graph_8h_source.html">Graph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
